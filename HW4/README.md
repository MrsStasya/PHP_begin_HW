## Урок 4. ООП
#1. Придумайте класс, который описывает любую сущность из предметной области библиотеки: книга, шкаф, комната и т.п.
Для описания Библиотеки можно взять три класса:
- Книга, который будет описывать в целом книгу
- Полка/Шкаф
- Помещение

#2. Опишите свойства классов из п.1 (состояние).
- Книга: $name, authors, $genre, $issueYear;
- Полка/Шкаф: shelfId, roomId, volume, books
- Помещение:  roomId, address, bookShelf;

#3. Опишите поведение классов из п.1 (методы).
- Книга: ; getName, getAuthor, getAuthors, getGenre, getIssueYear, takeBook
- Полка/Шкаф: getShelfId, getRoomId, getVolume, getBooksFromShelf, getCountBooks, placeBookInShelf
- Помещение: getRoomId, getAddress, getBookShelf;

$4. Придумайте наследников классов из п.1. Чем они будут отличаться?
Возьмем класс Книга. Наследниками класса могут быть бумажная книга и цифровая книга
Отличаться они будут методами возврата книги. Бумажную книгу мы должны физически выдать из библиотеки, то есть в методе takeBook - будет описан алгоритм физической выдачи книгииз библиотеки
Цифровую книгу физически вернуть в библиотеку нельзя, поэтому метод takeBook - будет представлять собой описание алгоритма скачивания пользователем книги.
Также у физическобумажной книги из библиотеки должен быть метод возврата книги returnBook, который будет описывать алгоритм физического возврата книги в библиотеку


#5. Создайте структуру классов ведения книжной номенклатуры.
— Есть абстрактная книга. - abstract class  Book
— Есть цифровая книга(class DigitalBook extends Book), бумажная книга (class PaperBook extends Book)
— У каждой книги есть метод получения на руки.
Метод #takeBook - метод, который наследуется из абстрактного класса Book, но переопределяется для цифровой и бумажной книги 

Для бумажной книги 
public function takeBook(string $name): string
    {
        return 'Книга: ' . $this->getName() . ', автор: ' . $this->getAuthor() . ', жанр: ' . $this->getGenre() . ', год: ' . $this->getIssueYear() . ', получена пользователем ' . $name . ' Количество прочтений: ' . ++$this->countRead;
    }

    Для цифровой книги
     public function takeBook(string $name): string
    {
        return 'Книга ' . $this->getName() . ', автор: ' . $this->getAuthor() . ', жанр: ' . $this->getGenre() . ', год: ' . $this->getIssueYear() . ', (' . $this->url . '), скачана пользователем ' . $name . ' Количество скачиваний книги: ' . ++$this->countDownload;
    }



У цифровой книги надо вернуть ссылку на скачивание, а у физической – адрес библиотеки, где ее можно получить. У всех книг формируется в конечном итоге статистика по кол-ву прочтений.
Что можно вынести в абстрактный класс, а что надо унаследовать?
Наследовать нужно свойства и основные методы класса, которые бубут в общем характеризовать любую книгу и будут присущи для любой книги
А вот в отдельных классах могут быть свойства или методы, которые присущи только для данного класса. В нашем примере переопределяектся метод takeBook для класса PaperBook и DigitalBook, которые являются наследниками абстрактного класса Book
Также в классе PaperBook описывается метод returnBook, который присущ только данному классу. В принципе его можно было бы описать в классе Book, так как идея библиотеки подразумевает временное пользование книгами, но тогда бы пришлось его переопределять в каждом классе отдельно, так как метод возврата для бумажной книги - свой, для электронной книги - его фактически нет