## Урок 4. ООП
#1. Придумайте класс, который описывает любую сущность из предметной области библиотеки: книга, шкаф, комната и т.п.
Для описания Библиотеки можно взять три класса:
- Книга, который будет описывать в целом книгу
- Полка/Шкаф
- Помещение

#2. Опишите свойства классов из п.1 (состояние).
- Книга: $name, authors, $genre, $issueYear;
- Полка/Шкаф: shelfId, roomId, volume, books
- Помещение:  roomId, address, bookShelf;

#3. Опишите поведение классов из п.1 (методы).
- Книга: ; getName, getAuthor, getAuthors, getGenre, getIssueYear, takeBook
- Полка/Шкаф: getShelfId, getRoomId, getVolume, getBooksFromShelf, getCountBooks, placeBookInShelf
- Помещение: getRoomId, getAddress, getBookShelf;

$4. Придумайте наследников классов из п.1. Чем они будут отличаться?
Возьмем класс Книга. Наследниками класса могут быть бумажная книга и цифровая книга
Отличаться они будут методами возврата книги. Бумажную книгу мы должны физически выдать из библиотеки, то есть в методе takeBook - будет описан алгоритм физической выдачи книгииз библиотеки
Цифровую книгу физически вернуть в библиотеку нельзя, поэтому метод takeBook - будет представлять собой описание алгоритма скачивания пользователем книги.
Также у физическобумажной книги из библиотеки должен быть метод возврата книги returnBook, который будет описывать алгоритм физического возврата книги в библиотеку


#5. Создайте структуру классов ведения книжной номенклатуры.
— Есть абстрактная книга. - abstract class  Book
— Есть цифровая книга(class DigitalBook extends Book), бумажная книга (class PaperBook extends Book)
— У каждой книги есть метод получения на руки.
Метод #takeBook - метод, который наследуется из абстрактного класса Book, но переопределяется для цифровой и бумажной книги 

Для бумажной книги 
public function takeBook(string $name): string
    {
        return 'Книга: ' . $this->getName() . ', автор: ' . $this->getAuthor() . ', жанр: ' . $this->getGenre() . ', год: ' . $this->getIssueYear() . ', получена пользователем ' . $name . ' Количество прочтений: ' . ++$this->countRead;
    }

    Для цифровой книги
     public function takeBook(string $name): string
    {
        return 'Книга ' . $this->getName() . ', автор: ' . $this->getAuthor() . ', жанр: ' . $this->getGenre() . ', год: ' . $this->getIssueYear() . ', (' . $this->url . '), скачана пользователем ' . $name . ' Количество скачиваний книги: ' . ++$this->countDownload;
    }



У цифровой книги надо вернуть ссылку на скачивание, а у физической – адрес библиотеки, где ее можно получить. У всех книг формируется в конечном итоге статистика по кол-ву прочтений.
Что можно вынести в абстрактный класс, а что надо унаследовать?
Наследовать нужно свойства и основные методы класса, которые бубут в общем характеризовать любую книгу и будут присущи для любой книги
А вот в отдельных классах могут быть свойства или методы, которые присущи только для данного класса. В нашем примере переопределяектся метод takeBook для класса PaperBook и DigitalBook, которые являются наследниками абстрактного класса Book
Также в классе PaperBook описывается метод returnBook, который присущ только данному классу. В принципе его можно было бы описать в классе Book, так как идея библиотеки подразумевает временное пользование книгами, но тогда бы пришлось его переопределять в каждом классе отдельно, так как метод возврата для бумажной книги - свой, для электронной книги - его фактически нет

6. Дан код:

class A {
public function foo() {
static $x = 0;
echo ++$x;
}
}
$a1 = new A();
$a2 = new A();
$a1->foo();
$a2->foo();
$a1->foo();
$a2->foo();

Что он выведет на каждом шаге? Почему?
6.1. class A {
public function foo() {
static $x = 0;
echo ++$x;
}
}
Статическая переменная, объявленная в публичном методе foo() класса A, изменяется при изменении в любом из созданных объектов класса. Каждый последующий вызов функции foo() увеличивает переменнyю $x  на единицу каким бы объектом класса А не вызывалась. А т.к. инкремент префиксный, то переменная $x сначала увеличивается на единицу, а затем выводится на экран. 

6.2. Объявляем переменные a1 и a2
$a1 = new A();
$a2 = new A();

6.3. Далее вызываем функцию foo
$a1->foo(); - выведет 1
$a2->foo(); - выведет 2
$a1->foo(); - выведет 3
$a2->foo(); - выведет 4
Итого в консоле будет выведено: 1234
При постфискном инкременте результат вывода был бы: 0123

Немного изменим п.5

class A {
public function foo() {
static $x = 0;
echo ++$x;
}
}
class B extends A {
}
$a1 = new A();
$b1 = new B();
$a1->foo();
$b1->foo();
$a1->foo();
$b1->foo();
Что он выведет теперь?

Выведено будет 1234, т.е. ничего не изменится, т.к. B просто наследует класс A, но в нет переопределения метода foo

